#!/bin/bash

#=============================================================================#
#        FILE: bashmount                                                      #
#     VERSION: f_0.1.1                                                        #
# DESCRIPTION: bashmount is a menu-driven bash script that can use different  #
#              backends to easily mount, unmount or eject removable devices   #
#              without dependencies on udisks or any GUI. An extensive        #
#              configuration file allows many aspects of the script to be     #
#              modified and custom commands to be run on devices.             #
#     LICENSE: GPLv2                                                          #
#     AUTHORS: Jamie Nguyen                                                   #
#              Lukas B.                                                       #
#=============================================================================#

# Copyright (C) 2013 Jamie Nguyen, 2014 Lukas B.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License v2 as published by the
# Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA

declare -r VERSION='f_0.1.1'

# CONFIGURATION
# Make sure that user defined options will not interfere with grep.
unset GREP_OPTIONS

# Set defaults.
declare mount_options='--options nosuid,noexec,relatime'
declare -i show_internal=1
declare -i show_removable=1
declare -i show_optical=1
declare -i show_commands=1
declare -i colourize=1
declare -i show_device_path=1
declare -i custom1_show=0
declare -i custom2_show=0
declare -i custom3_show=0
declare -i custom4_show=0
declare -i custom5_show=0
declare -i custom6_show=0
declare -i run_post_mount=0
declare -i run_post_unmount=0
declare -a blacklist=()

mount_command() {
	read -r -e -p 'Choose the mountpoint directory: ' dir
	while [[ ! -d "$dir" ]] || findmnt "$dir" >/dev/null 2>&1; do
		echo '(No such directory, or mountpoint is already in use.)'
		read -r -e -p 'Choose the mountpoint directory: ' dir
	done
	mount ${mount_options} "$1" "$dir"
}

unmount_command() {
	umount "$1"
}

filemanager() {
	cd "$1" && "$SHELL"
	exit 0
}

post_mount() {
	error "No command specified in 'bashmount.conf'."
	return 1
}

post_unmount() {
	error "No command specified in 'bashmount.conf'."
	return 1
}

# Load configuration file.
declare CONFIGFILE=

if [[ -z "$XDG_CONFIG_HOME" ]]; then
	CONFIGFILE="${HOME}/.config/bashmount/config"
else
	CONFIGFILE="${XDG_CONFIG_HOME}/bashmount/config"
fi

if [[ ! -f "$CONFIGFILE" ]]; then
	CONFIGFILE='/etc/bashmount.conf'
fi

if [[ -f "$CONFIGFILE" ]]; then
	if ! . "$CONFIGFILE"; then
		echo 'bashmount: Failed to source configuration file.'
		exit 78
	fi
fi

# GENERAL FUNCTIONS

unset ALL_OFF BOLD BLUE GREEN RED
if (( colourize )); then
	if tput setaf 0 >/dev/null 2>&1; then
		ALL_OFF="$(tput sgr0)"
		BOLD="$(tput bold)"
		BLUE="${BOLD}$(tput setaf 4)"
		GREEN="${BOLD}$(tput setaf 2)"
		RED="${BOLD}$(tput setaf 1)"
	else
		ALL_OFF='\e[1;0m'
		BOLD='\e[1;1m'
		BLUE="${BOLD}\e[1;34m"
		GREEN="${BOLD}\e[1;32m"
		RED="${BOLD}\e[1;31m"
	fi
	readonly ALL_OFF BOLD BLUE GREEN RED
fi

msg() {
	echo "${GREEN}==>${ALL_OFF}${BOLD} ${@}${ALL_OFF}" >&2
}

error() {
	echo "${RED}==>${ALL_OFF}${BOLD} ERROR: ${@}${ALL_OFF}"
}

clear_screen() {
	clear
	echo "bashmount ${VERSION}"
	echo
}

print_commands() {
	print_separator_commands
	echo -n "${BLUE}e${ALL_OFF}: eject   ${BLUE}i${ALL_OFF}: info   ${BLUE}m${ALL_OFF}: mount"
	echo "   ${BLUE}o${ALL_OFF}: open   ${BLUE}u${ALL_OFF}: unmount"
	echo
	echo -n "${BLUE}a${ALL_OFF}: unmount all   ${BLUE}r${ALL_OFF}: refresh"
	echo "   ${BLUE}q${ALL_OFF}: quit   ${BLUE}?${ALL_OFF}: help"
	echo
}

print_submenu_commands() {
	print_separator_commands
	echo -n "${BLUE}e${ALL_OFF}: eject   ${BLUE}i${ALL_OFF}: info"
	if info_mounted "$devname"; then
		echo -n "   ${BLUE}u${ALL_OFF}: unmount"
	else
		echo -n "   ${BLUE}m${ALL_OFF}: mount"
	fi
	echo -n "   ${BLUE}o${ALL_OFF}: open"
	echo
	echo -n "${BLUE}b${ALL_OFF}: back   ${BLUE}r${ALL_OFF}: refresh"
	echo "   ${BLUE}q${ALL_OFF}: quit   ${BLUE}?${ALL_OFF}: help"

	if (( custom1_show )) || (( custom2_show )) || (( custom3_show )); then
		echo
	fi

	if (( custom1_show )) && [[ -n "$custom1_desc" ]]; then
		echo -n "${BLUE}1${ALL_OFF}: ${custom1_desc}"
	fi

	if (( custom2_show )) && [[ -n "$custom2_desc" ]]; then
		echo -n "   ${BLUE}2${ALL_OFF}: ${custom2_desc}"
	fi

	if (( custom3_show )) && [[ -n "$custom3_desc" ]]; then
		echo -n "   ${BLUE}3${ALL_OFF}: ${custom3_desc}"
	fi

	if (( custom1_show )) || (( custom2_show )) || (( custom3_show )); then
		echo
	fi

	if (( custom4_show )) || (( custom5_show )) || (( custom6_show )); then
		echo
	fi

	if (( custom4_show )) && [[ -n "$custom4_desc" ]]; then
		echo -n "${BLUE}4${ALL_OFF}: ${custom4_desc}"
	fi

	if (( custom5_show )) && [[ -n "$custom5_desc" ]]; then
		echo -n "   ${BLUE}5${ALL_OFF}: ${custom5_desc}"
	fi

	if (( custom6_show )) && [[ -n "$custom6_desc" ]]; then
		echo -n "   ${BLUE}6${ALL_OFF}: ${custom6_desc}"
    fi

	if (( custom4_show )) || (( custom5_show )) || (( custom6_show )); then
		echo
	fi
}

enter_to_continue() {
	echo
	read -r -e -p "Press [${BLUE}enter${ALL_OFF}] to continue: " null
}

invalid_command() {
	echo
	error 'Invalid command. See the help menu.'
	enter_to_continue
}

print_separator() {
	echo '====================================================='
	echo
}

print_separator_commands() {
	echo '===================== COMMANDS ======================'
	echo
}

print_separator_device() {
	echo '==================== DEVICE MENU ===================='
	echo
}

print_separator_optical() {
	echo '=================== OPTICAL MEDIA ==================='
	echo
}

print_separator_removable() {
	echo '================== REMOVABLE MEDIA =================='
	echo
}

print_separator_internal() {
	echo '================== INTERNAL MEDIA ==================='
	echo
}

print_help() {
	clear_screen
	print_commands
	print_separator
	echo -n "${GREEN}==>${ALL_OFF} "
	echo -n "${BOLD}To mount the first device, enter ${ALL_OFF}"
	echo -n "${BLUE}1m${ALL_OFF}"
	echo "${BOLD}.${ALL_OFF}"
	echo -n "${GREEN}==>${ALL_OFF} "
	echo "${BOLD}To open the mountpath directory of the first${ALL_OFF}"
	echo -n "${BOLD}    device (mounting if required), enter "
	echo -n "${BLUE}1o${ALL_OFF}"
	echo "${BOLD}.${ALL_OFF}"
	echo -n "${GREEN}==>${ALL_OFF} "
	echo -n "${BOLD}To view a device sub-menu, "
	echo "just enter the number.${ALL_OFF}"
	echo -n "${GREEN}==>${ALL_OFF} "
	echo -n "${BLUE}a${ALL_OFF}"
	echo -n "${BOLD}, "
	echo -n "${BLUE}r${ALL_OFF}"
	echo -n "${BOLD}, "
	echo -n "${BLUE}q${ALL_OFF} "
	echo -n "${BOLD}and "
	echo -n "${BLUE}?${ALL_OFF} "
	echo "${BOLD}do not require a number.${ALL_OFF}"
	print_separator
	enter_to_continue
}

print_help_sub() {
	clear_screen
	print_submenu_commands
	print_separator
	echo -n "${GREEN}==>${ALL_OFF} "
	echo "${BOLD}To perform a command, enter a character.${ALL_OFF}"
	echo -n "${GREEN}==>${ALL_OFF} "
	echo -n "${BOLD}For example, to mount this device, enter ${ALL_OFF}"
	echo -n "${BLUE}m${ALL_OFF}"
	echo "${BOLD}.${ALL_OFF}"
	print_separator
	enter_to_continue
}

# INFORMATION RETRIEVAL
info_removable() {
	[[ "$(lsblk -drno RM "$1")" = '1' ]]
}
# Returns 0, if the device is registered as removable device in the kernel, 1 otherwise.

info_type() {
	lsblk -drno TYPE "$1"
}
# Prints the device type, for example partition or disk.

info_fslabel() {
	lsblk -drno LABEL "$1"
}
# Prints the filesystem label, if present.

info_partlabel() {
	lsblk -drno PARTLABEL "$1"
}
# Prints the partition label, if present.

info_mountpath() {
	findmnt -no TARGET "$1"
}
# Prints the mountpath, if mounted.

info_mounted() {
	findmnt -no TARGET "$1" >/dev/null 2>&1
}
# Returns 0 if the device is mounted, 1 otherwise.

info_fstype() {
	lsblk -drno FSTYPE "$1"
}
# Prints the filesystem type.

info_size() {
	lsblk -drno SIZE "$1"
}
# Prints the device size.

# DEVICE MANIPULATION
check_device() {
	if [[ ! -b "$1" ]]; then
		echo
		error "${1} is no longer available."
		enter_to_continue
		return 1
	fi
	return 0
}

action_eject() {
	check_device "$1" || return 1
	info_mounted "$1" && action_unmount "$1"
	if ! info_mounted "$1"; then
		echo
		msg "Ejecting ${1} ..."
		echo
		eject "$1"
		# Give the device some time to eject. If we don't then sometimes the ejected
		# device will still be present when returning to the main menu.
		enter_to_continue
		sleep 2
	fi
}

action_info() {
	check_device "$1" || return 1
	lsblk -o NAME,FSTYPE,MOUNTPOINT,SIZE "$1" | less
}

action_mount() {
	check_device "$1" || return 1
	echo
	if info_mounted "$1"; then
		error "${1} is already mounted."
	else
		msg "Mounting ${1} ..."
		if mount_command "$1"; then
			msg "${1} mounted succesfullly."
			(( run_post_mount )) && post_mount "$1"
		else
			echo
			error "${1} could not be mounted."
		fi
	fi
	enter_to_continue
}

action_open() {
	if ! info_mounted "$1"; then
		echo
		msg "Mounting ${1} ..."
		if mount_command "$1"; then
			msg "${1} mounted succesfullly."
			(( run_post_mount )) && post_mount "$1"
		else
			echo
			error "${1} could not be mounted."
			enter_to_continue
			return 1
		fi
	fi
	echo
	msg "Opening ${1} ..."
	echo
	filemanager "$(info_mountpath "$1")"
	enter_to_continue
}

action_unmount() {
	echo
	if info_mounted "$1"; then
		msg "Unmounting ${1} ..."
		echo
		if unmount_command "$1"; then
			msg "${1} unmounted successfully."
			(( run_post_unmount )) && post_unmount "$1"
		else
			echo
			error "${1} could not be unmounted."
		fi
	else
		error "${1} is not mounted."
	fi
	enter_to_continue
}

list_devices() {
	local -a all=() removable=() internal=() optical=()
	# The array "all" contains the sorted list of devices returned by lsblk.
	all=( $(lsblk -plno NAME) )
	# The array "listed" contains all devices that are shown to the user.
	listed=()
	# The array "mounted" contains all devices that are listed and mounted.
	mounted=()
	# "device_number" is the total number of devices listed and equals ${#listed[*]}.
	device_number=0
	for devname in ${all[@]}; do
		# Hide blacklisted devices.
		for string in ${blacklist[@]}; do
			lsblk -dPno NAME,FSTYPE,LABEL,MOUNTPOINT,PARTLABEL "$devname" | grep -E \
"$string" >/dev/null 2>&1
			(( $? )) || continue 2
		done
		type=$(info_type "$devname")
		# Sort devices into arrays removable,internal, and optical.
		if [[ "$type" = 'part' || "$type" = 'crypt' ]]; then
			if info_removable "$devname"; then
				removable[${#removable[*]}]="$devname"
			else
				internal[${#internal[*]}]="$devname"
			fi
		elif [[ "$type" = 'rom' ]]; then
			optical[${#optical[*]}]="$devname"
		else
			continue
		fi
	done
	# Print output.
	# List internal media.
	if (( show_internal )) && (( ${#internal[*]} )); then
		print_separator_internal
		for devname in ${internal[@]}; do
			info_label="$(info_fslabel "$devname")"
			if [[ -z "$info_label" ]]; then
				info_label="$(info_partlabel "$devname")"
				if [[ -z "$info_label" ]]; then
					info_label='No label'
				fi
			fi
			listed[device_number]="$devname"
			(( device_number++ ))
			echo -n "${BLUE}${device_number})${ALL_OFF}"
			(( show_device_path )) && echo -n " ${devname:5}:"
			echo -n " ${info_label}"
			if info_mounted "$devname"; then
				echo -n " ${GREEN}[mounted]${ALL_OFF}"
				mounted[${#mounted[*]}]="$devname"
			fi
			echo
		done
	fi
	# List removable media.
	if (( show_removable )) && (( ${#removable[*]} )); then
		echo
		print_separator_removable
		for devname in ${removable[@]}; do
			info_label="$(info_fslabel "$devname")"
			if [[ -z "$info_label" ]]; then
				info_label="$(info_partlabel "$devname")"
				if [[ -z "$info_label" ]]; then
					info_label='No label'
				fi
			fi
			listed[device_number]="$devname"
			(( device_number++ ))
			echo -n "${BLUE}${device_number})${ALL_OFF}"
			(( show_device_path )) && echo -n " ${devname:5}:"
			echo -n " ${info_label}"
			if info_mounted "$devname"; then
				echo -n " ${GREEN}[mounted]${ALL_OFF}"
				mounted[${#mounted[*]}]="$devname"
			fi
			echo
		done
	fi
	# List optical media.
	if (( show_optical )) && (( ${#optical[*]} )); then
		echo
		print_separator_optical
		for devname in ${optical[@]}; do
			info_label="$(info_fslabel "$devname")"
			if [[ -z "$info_label" ]]; then
				info_label="$(lsblk -dno MODEL "$devname")"
				if [[ -z "$info_label" ]]; then
					info_label='No label'
				fi
			fi
			listed[device_number]="$devname"
			(( device_number++ ))
			echo -n "${BLUE}${device_number})${ALL_OFF}"
			(( show_device_path )) && echo -n " ${devname:5}:"
			echo -n " ${info_label}"
			if info_mounted "$devname"; then
				echo -n " ${GREEN}[mounted]${ALL_OFF}"
				mounted[${#mounted[*]}]="$devname"
			fi
			echo
		done
	fi
	(( device_number )) || echo 'No devices.'
	echo
}

submenu() {
	check_device "$devname" || return 1
	local info_label= info_fstype= info_size=
	info_label="$(info_fslabel "$devname")"
	if [[ -z "$info_label" ]]; then
		info_label="$(info_partlabel "$devname")"
		if [[ -z "$info_label" ]]; then
			info_label='-'
		fi
	fi
	info_fstype="$(info_fstype "$devname")"
	info_size="$(info_size "$devname")"
	clear_screen
	print_separator_device
	echo "device    : ${devname}"
	echo "label     : ${info_label}"
	echo -n 'mounted   : '
	if info_mounted "$devname"; then
		echo "${GREEN}yes${ALL_OFF}"
		echo "mountpath : $(info_mountpath "$devname")"
	else
		echo "${RED}no${ALL_OFF}"
	fi
	echo "fstype    : ${info_fstype}"
	echo "size      : ${info_size}"
	if (( show_commands )); then
		echo
		print_submenu_commands
	fi
	echo
	print_separator
	echo
	read -r -e -p 'Command: ' action
	case "$action" in
		'e')	action_eject "$devname";;
		'i')	action_info "$devname";;
		'm')	action_mount "$devname";;
		'o')	action_open "$devname";;
		'u')	action_unmount "$devname";;
		'b')	return 1;;
		'r')	return 0;;
		'q')	exit;;
		'?')	print_help_sub
			return 0;;
		'1')	if (( custom1_show )); then
				echo
				msg "Running custom command ${custom1_desc} ..."
				echo
				custom1_command "$devname"
				enter_to_continue
			else
				invalid_command
			fi
			return 0;;
		'2')	if (( custom2_show )); then
				echo
				msg "Running custom command ${custom2_desc} ..."
				echo
				custom2_command "$devname"
				enter_to_continue
			else
				invalid_command
			fi
			return 0;;
		'3')	if (( custom3_show )); then
				echo
				msg "Running custom command ${custom3_desc} ..."
				echo
				custom3_command "$devname"
				enter_to_continue
			else
				invalid_command
			fi
			return 0;;
		'4')	if (( custom4_show )); then
				echo
				msg "Running custom command ${custom4_desc} ..."
				echo
				custom4_command "$devname"
				enter_to_continue
			else
				invalid_command
			fi
			return 0;;
		'5')	if (( custom5_show )); then
				echo
				msg "Running custom command ${custom5_desc} ..."
				echo
				custom5_command "$devname"
				enter_to_continue
			else
				invalid_command
			fi
			return 0;;
		'6')	if (( custom6_show )); then
				echo
				msg "Running custom command ${custom6_desc} ..."
				echo
				custom6_command "$devname"
				enter_to_continue
			else
				invalid_command
			fi
			return 0;;
		*)	invalid_command
			return 0;;
	esac
}

select_action() {
	local devname= letter=
	local -i number=
	print_separator
	echo
	read -r -e -p "Command: " action
	if [[ "$action" =~ ^[1-9][0-9]*[eimou]?$ ]]; then
		if (( ${#action} == 1 )); then
			number="$(( action - 1 ))"
			if (( number >= device_number )); then
				invalid_command
				return 1
			fi
			devname=${listed[number]}
			while :; do
				submenu || break
			done
		else
			number="$(( ${action%?} - 1 ))"
			letter="${action: -1}"
			if (( number >= device_number )); then
				invalid_command
				return 1
			fi
			devname="${listed[number]}"
			case "$letter" in
				'e')	action_eject "$devname";;
				'i')	action_info "$devname";;
				'm')	action_mount "$devname";;
				'o')	action_open "$devname";;
				'u')	action_unmount "$devname";;
				*)	return 1;;
			esac
			return 0
		fi
	else
		case "$action" in
			'a')	echo
				if (( ! ${#mounted[*]} )); then
					error 'No devices mounted.'
					enter_to_continue
					return 1
				fi
				read -r -e -p 'Unmount all devices [y/N]?: ' unmount
				if [[ "$unmount" != 'y' ]] && [[ "$unmount" != 'Y' ]]; then
					return 0
				fi
				clear_screen
				for devname in ${mounted[@]}; do
					action_unmount "$devname" || continue
				done
				enter_to_contine
				return 1;;
			'r')	return 0;;
			'q'|'b')	exit 0;;
			'?')	print_help
				return 0;;
			*)	invalid_command
				return 1;;
		esac
	fi
}

declare -i device_number=
declare -a mounted=()
declare -a listed=()

while :; do
	clear_screen
	list_devices
	(( show_commands )) && print_commands
	select_action
done
